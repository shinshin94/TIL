# Pandas

## Dataframe 인덱서

### loc, iloc

> - Pandas는 numpy행렬과 같이 쉼표를 사용한 (행 인덱스, 열 인덱스) 형식의 2차원 인덱싱을 지원
> - 특별한 인덱서(indexer) 속성을 제공
> - loc : 라벨값 기반의 2차원 인덱싱
> - iloc : 순서를 나타내는 정수 기반의 2차원 인덱싱
>
> 데이터프레임 인덱싱
>
> 1. 열인덱싱
>    - 하나의 열만 선택 : df['열이름']
>    - 여러개 열 선택 : df[['열이름1', '열이름2',...]]
>
> 1. 행인덱싱 : 연속된 구간의 행데이터 선택(슬라이싱)
>    - df['행_시작위치':'행_끝위치'] :
>
> 1. 개별요소 접근 : 선택한 열에서 지정된 구간의 행데이터 선택
>    - df['열이름']['행_시작위치':'행_끝위치']
>    - df['열이름']['시작_행이름':'끝_행이름']
>
> => 행과 열을 동시에 인덱싱 하는 구조는 기본 자료구조 인덱스와 차이가 있음
>
### 데이터 프레임에서 인덱서 사용
#### loc, iloc 속성을 사용하는 인덱싱
>
> - pandas 패키지는 [행번호,열번호] 인덱싱 불가
> - iloc 속성 사용하면 가능
>   - iloc[행번호,열번호] : 가능
>   - loc[행제목,열제목] : 가능
>
>   loc 인덱서 (행 우선 인덱서)
>
> - df.loc[행인덱싱 값] # 행우선 인덱서
> - df.loc[행인덱싱 값,열인덱싱 값]
>
#### 인덱싱 값
>
>1. 인덱스 데이터 : (index name, column name)
>2. 인덱스 데이터 슬라이스
>3. 같은 행 인덱스를 갖는 불리언 시리즈(행 인덱싱인 경우)
>   - 조건으로 추출 가능
>4. 위 값을 반환하는 함수
>
>```
>df = pd.DataFrame(np.arange(10,22).reshape(3,4),
>                 index='a b c'.split(),
>                 columns = 'A B C D'.split())
>```
>
>* loc 인덱서 : 인덱싱 값을 하나만 받는 경우
>
>  * ```
>    df.loc['a']
>    ```
>
>  * loc 인덱서에서는 열 단독 인덱싱은 불가능 함
>
>* 행이름 문자열 라벨 슬라이싱
>
>* dataFrame.loc[처음문자열제목 : 끝문자열제목]
>
>  * ```
>    df.loc['b':'c']
>    ```
>
>  * ```
>    df['b':'c']
>    ```
>
>* dataFrame[[행이름1, 행이름2,... ]]
>
>  - 여러 행 선택시 인덱서 데이터를 리스트로 사용
>
>  - 반환값이 데이터프레임이 됨
>
>  - ```
>    df.loc[['a','c']]
>    ```
>
>  - ```
>    df.loc['b']
>    ```
>
>  - 

#### boolean selection으로 row 선택하기

> * 데이터베이스와 같은 인덱스를 가지는 boolean selection을 행을 선택하는 인덱싱 값으로 쓸 수 있음
>
> * 조건 식 수행
>
> * df의 A열의 값이 15보다 큰 행만 추출
>
>   * ```
>     df.A > 15
>     ```
>
> * df의 A열의 행값이 15보다 큰지 확인 후 T/F로 반환
>
>   * ```
>     df.loc[df.A > 15]
>     ```
>
>   * ```
>     df[df.A > 15]
>     ```
>
> * 인덱스 대신 인덱스 값을 반환하는 함수 사용
>
>   * ```
>     def sel_row(df):
>         return df.A > 15
>     ```
>
>   * ```
>     sel_row(df)
>     ```

### loc 인덱서 슬라이싱

> * 값 인덱싱 - 슬라이싱 초기값:끝값
>
>   * ```
>     df2.loc[1:2]
>     ```
>
> * 위치 인덱싱 - 슬라이싱 초기위치:끝위치 + 1
>
>   * ```
>     df2[1:2]
>     ```

### loc 인덱서 사용 요소 값 접근

> - 인덱싱으로 행과 열을 모두 받는 경우
>
> - 문법 : df.loc[행인덱스, 열인덱스] - 라벨(문자열)인덱스 사용
>
> - a행의 A열 값을 접근해서 출력
>
>   - ```
>     df.loc['a','A']
>     ```
>
> - df.loc[행,열]=값 (loc를 사용한 원소값 변경)
>
>   - ```
>     df.loc['a','A']=50
>     ```
>
> - ```
>   df.loc['a':'b']  # a,b행의 모든열 df 형태로 반환
>   df.loc[['a','b']]# a,b행의 모든열 df 형태로 반환
>   df.loc[['a','b'],'B'] # a,b행의 B열을 시리즈 반환
>   df.loc['a':'b','B']   # a,b행의 B열을 시리즈 반환
>   df.loc['a':'b',['B','D']] # a,b행의 B,D열을 df로 반환
>   df.loc[['a','b'],['B','D']] # a,b행의 B,D열을 df로 반환
>   ```

###  iloc 인덱서(위치 인덱스)

> - 라벨(name)이 아닌 위치를 나타내는 정수 인덱스만 받는다.
>
> - 위치 정수값은 0부터 시작
>
> - 데이터프레임.iloc[행,열]
>
> - 1열의 0행,1행 선택 : 데이터프레임 형태로 반환
>
>   - ```
>     df.iloc[0:2,1:2]
>     ```
>
> - 1열의 0행,1행 선택 : 시리즈 형태로 반환
>
>   - ```
>     df.iloc[0:2,1]
>     ```
>
> - iloc[행위치,열위치] -> 원소값 반환
>
> - iloc[행위치1:행위치2,열위치1:열위치2] -> 원소 반환: df 반환
>
> - iloc[행위치,열위치1:열위치2] -> 원소반환 :시리즈 반환
>
> - iloc[행위치1:행위치2,열위치] ->원소반환 : 시리즈 반환
>
> - ```
>   # 인덱싱 예제
>   df["A"] #열 라벨 인덱싱, A열을 추출 - 시리즈
>   df[0:3] #0행부터 2행까지 추출-슬라이싱 사용(행인덱싱)
>   df["A"]["a"] #열행 인덱싱 - 원소값 a행 A열-열우선인덱싱
>   df.iloc[1,3:]#1행의 3,4열(D,E열)
>   df.loc["a":"c","B":"D"] #df로 반환(행,열 모두 슬라이싱처리)
>   df.iloc[-2:]#끝에서 두번째 행부터 마지막행까지 - df로 반환
>   df.loc["a","A":"B"] #시리즈로 반환
>   df.loc["a":"a","A":"B"]#df로 반환
>   df.iloc[-2:,-2:] #행,열 슬라이싱 처리 -df 형태로 나타남
>   df[:"b"]["A"] #시리즈 출력
>   df[:"b"][["A"]] #df 출력
>   ```

### 원소 갯수 세기

> * 원소들을 분류하여 갯수를 세는 함수 : value_counts()
>
>   * ```
>     df.value_counts()
>     ```





