# NumPy

>* c언어로 구현된 파이썬 라이브러리(외부 라이브러리)
>* 고성능 수치 계산을 위해 만들어진 파이썬 패키지
>* Vector,matrix,n-th array(ndarray) 등의 데이터 분석을 위한 패키지
>* 벡터 및 행렬 연산에 있어서 매우 편리한 기능을 제공
> * numpy 모듈 선언
>   * `import numpy as np`
>
> * 배열 단위로 데이터를 관리하며 연산을 수행
>* Numpy의 기본 단위가 되는 array는 Dynamic type을 지원하지 않음. 한 타입만 지원
>
>* 1차원의 Numpy array : Vector
>* 2차원의 Numpy array : Matirx
>* 3차원 이상의 Numpy array : Tensor
>

## array (배열)

> 시퀀스 데이터(리스트,튜플 등)로부터 배열 생성

### shape

> 크기 확인
>
> `변수명.shape`  

### dtype

> 자료형 확인
>
> `변수명.dtype`

## numpy 자료형
>- 부호가 있는 정수 int(8, 16, 32, 64)
>- 부호가 없는 정수 uint(8 ,16, 32, 64)
>- 실수 float(16, 32, 64, 128)
>- 복소수 complex(64, 128, 256)
>- 불리언 bool
>- 문자열 string_
>- 파이썬 오프젝트 object
>- 유니코드 unicode_

## arange (범위)

> 범위를 지정해 배열 생성
>
> 리스트형태로 나온다
>
> `arr_obj = np.arange([start,] stop[, step])`

### reshape

> 다중차원으로 만들때 사용한다
>
> `np.arange(12).reshape(3,4)`
>
> ```
> array([[ 0,  1,  2,  3],
>        [ 4,  5,  6,  7],
>        [ 8,  9, 10, 11]])
> ```

## linspace(범위)

> 범위를 지정해 배열 생성
>
> `arr.obj = np.linspace(start, stop[, num=50])`
>
> `np.linspace(1,10)`
>
> ```
> array([ 1.        ,  1.18367347,  1.36734694,  1.55102041,  1.73469388,
>         1.91836735,  2.10204082,  2.28571429,  2.46938776,  2.65306122,
>         2.83673469,  3.02040816,  3.20408163,  3.3877551 ,  3.57142857,
>         3.75510204,  3.93877551,  4.12244898,  4.30612245,  4.48979592,
>         4.67346939,  4.85714286,  5.04081633,  5.2244898 ,  5.40816327,
>         5.59183673,  5.7755102 ,  5.95918367,  6.14285714,  6.32653061,
>         6.51020408,  6.69387755,  6.87755102,  7.06122449,  7.24489796,
>         7.42857143,  7.6122449 ,  7.79591837,  7.97959184,  8.16326531,
>         8.34693878,  8.53061224,  8.71428571,  8.89795918,  9.08163265,
>         9.26530612,  9.44897959,  9.63265306,  9.81632653, 10.        ])
> ```

## 특별한 형태의 배열 생성

### np.zeros()

>  **모든 요소가 0인 배열 생성**
>
> `np.zeros(shape, dtype=float, ...)`
>
> `np.zeros((3,5)).reshape(5,3)`
>
> ```
> array([[0., 0., 0.],
>        [0., 0., 0.],
>        [0., 0., 0.],
>        [0., 0., 0.],
>        [0., 0., 0.]])
> ```

### np.ones()

> **모든 요소가 1인 배열 생성** 
>
> `np.ones(shape, dtype=None)`
>
> `np.ones((3,5), dtype=int)`
>
> ```
> array([[1, 1, 1, 1, 1],
>        [1, 1, 1, 1, 1],
>        [1, 1, 1, 1, 1]])
> ```

###  np.eye()

> **대각요소가 1인 배열 생성1**
>
> `np.eye(n, m, k=K, dtype=float)`
>
> `np.eye(3,4, k=2)`
>
> ```
> array([[0., 0., 1., 0.],
>        [0., 0., 0., 1.],
>        [0., 0., 0., 0.]])
> ```

###  np.identity()

> **대각요소가 1인 배열 생성2**
>
> `np.identity(n, dtype=자료형)`
>
> `np.identity(5, dtype=int)`
>
> ```
> array([[1, 0, 0, 0, 0],
>        [0, 1, 0, 0, 0],
>        [0, 0, 1, 0, 0],
>        [0, 0, 0, 1, 0],
>        [0, 0, 0, 0, 1]])
> ```

### np.empty()

> **초기화되지 않은 배열 생성**
>
> `np.empty(4)`
>
> ```
> array([0., 0., 0., 0.])
> ```

## astype()

> 배열의 데이터 타입 변환
>
> 바꿀수 없는 것은 오류가 나옴
>
>  `num_arr = str_arr.astype(dtype)`
>
> ` num_a1 = str_a1.astype('float32')`
>
> ```
> array([1.5     , 0.62    , 2.      , 3.14    , 3.141592]
> ```

## 난수 배열 생성

### random.rand()

> `random.rand([d0, d1, ..., dn])`
>
> - 0과 1 사이의 `실수` 난수를 갖는 NumPy 배열을 생성
> - rand(d0, d1, ..., dn)을 실행하면 (d0, d1, ..., dn)의 형태를 보이는 실수 난수 배열 생성
>
> `np.random.rand(2,3,4)`
>
> ```
> array([[[0.32320571, 0.81253569, 0.47599006, 0.06932435],
>         [0.66705447, 0.61810587, 0.32013262, 0.03288708],
>         [0.57588633, 0.93558938, 0.61371422, 0.4635101 ]],
> 
>        [[0.97524433, 0.20134363, 0.86962887, 0.68841211],
>         [0.23337261, 0.61820769, 0.10970224, 0.10675563],
>         [0.88698946, 0.42364217, 0.49028856, 0.91902302]]])
> ```

### random.randint()

> `random.randint([low,] high [,size])`
>
> - [low, high) 사이의 `정수` 난수를 갖는 NumPy 배열을 생성
> - size : (d0, d1, ..., dn) 형식으로 입력
>
> `np.random.randint(10, 20, size=(3,5))`
>
> ```
> array([[18, 19, 16, 19, 10],
>        [11, 12, 15, 10, 14],
>        [10, 10, 13, 17, 14]])
> ```

## array 연산

>* 기본 연산(합, 차, 곱, 나눗셈 등)
>
>* 기본적으로 동일한 크기의 array 간 연산 수행
>
>  `ex`
>
>  ```
>  arr1 = np.array([[1,3,4],[4,3,6]])
>  arr2 = np.arange(10,16).reshape(2,3)
>  ```

### 배열의 합

> `arr1 + arr2`
>
> ```
> array([[11, 14, 16],
>        [17, 17, 21]])
> ```

### 배열의 차

> `arr1 - arr2`
>
> ```
> array([[ -9,  -8,  -8],
>        [ -9, -11,  -9]])
> ```

### 배열의 곱

> `arr1 * arr2`
>
> ```
> array([[10, 33, 48],
>        [52, 42, 90]])
> ```

### 배열의 나눗셈

> `arr1 / arr2`
>
> ```
> array([[0.1       , 0.27272727, 0.33333333],
>        [0.30769231, 0.21428571, 0.4       ]])
> ```

### 배열의 스칼라 곱

> `arr2*2`
>
> ```
> array([[20, 22, 24],
>        [26, 28, 30]])
> ```

### 배열의 비교 연산

>`arr2 > 12`
>
>```
>array([[False, False, False],
>       [ True,  True,  True]])
>```

### 배열의 Broadcasting

> - 서로 크기가 다른 array들의 연산이 가능하도록 배열을 자동적으로 변환하여 연산 수행
> - 조건
>   - 두 배열 간의 연산에서 최소한 하나의 배열의 차원이 1인 경우(0번 축이든 1번 축이든; 1행이든 1열이든)
>   - 차원의 짝이 맞을 때(차원에 대해 축의 길이가 동일시)
>
> `ex)`
>
> ```
> arr1 =([[1, 3, 4],
>        [4, 3, 6]])
> arr3 = ([10,11,12])
> ```
>
> ```
> arr1 + arr3
> array([[11, 14, 16],
>        [14, 14, 18]])
> ```
>
> ```
> arr1 * 10
> array([[10, 30, 40],
>        [40, 30, 60]])
> ```
>
> ```
> array([[ 1,  9, 16],
>        [16,  9, 36]], dtype=int32)
> ```

