# NumPy

>* c언어로 구현된 파이썬 라이브러리(외부 라이브러리)
>* 고성능 수치 계산을 위해 만들어진 파이썬 패키지
>* Vector,matrix,n-th array(ndarray) 등의 데이터 분석을 위한 패키지
>* 벡터 및 행렬 연산에 있어서 매우 편리한 기능을 제공
> * numpy 모듈 선언
>   * `import numpy as np`
>
> * 배열 단위로 데이터를 관리하며 연산을 수행
>* Numpy의 기본 단위가 되는 array는 Dynamic type을 지원하지 않음. 한 타입만 지원
>
>* 1차원의 Numpy array : Vector
>* 2차원의 Numpy array : Matirx
>* 3차원 이상의 Numpy array : Tensor
>

## array (배열)

> 시퀀스 데이터(리스트,튜플 등)로부터 배열 생성

### shape

> 크기 확인
>
> `변수명.shape`  

### dtype

> 자료형 확인
>
> `변수명.dtype`

## numpy 자료형
>- 부호가 있는 정수 int(8, 16, 32, 64)
>- 부호가 없는 정수 uint(8 ,16, 32, 64)
>- 실수 float(16, 32, 64, 128)
>- 복소수 complex(64, 128, 256)
>- 불리언 bool
>- 문자열 string_
>- 파이썬 오프젝트 object
>- 유니코드 unicode_

## arange (범위)

> 범위를 지정해 배열 생성
>
> 리스트형태로 나온다
>
> `arr_obj = np.arange([start,] stop[, step])`

### reshape

> 다중차원으로 만들때 사용한다
>
> `np.arange(12).reshape(3,4)`
>
> ```
> array([[ 0,  1,  2,  3],
>        [ 4,  5,  6,  7],
>        [ 8,  9, 10, 11]])
> ```

## linspace(범위)

> 범위를 지정해 배열 생성
>
> `arr.obj = np.linspace(start, stop[, num=50])`
>
> `np.linspace(1,10)`
>
> ```
> array([ 1.        ,  1.18367347,  1.36734694,  1.55102041,  1.73469388,
>         1.91836735,  2.10204082,  2.28571429,  2.46938776,  2.65306122,
>         2.83673469,  3.02040816,  3.20408163,  3.3877551 ,  3.57142857,
>         3.75510204,  3.93877551,  4.12244898,  4.30612245,  4.48979592,
>         4.67346939,  4.85714286,  5.04081633,  5.2244898 ,  5.40816327,
>         5.59183673,  5.7755102 ,  5.95918367,  6.14285714,  6.32653061,
>         6.51020408,  6.69387755,  6.87755102,  7.06122449,  7.24489796,
>         7.42857143,  7.6122449 ,  7.79591837,  7.97959184,  8.16326531,
>         8.34693878,  8.53061224,  8.71428571,  8.89795918,  9.08163265,
>         9.26530612,  9.44897959,  9.63265306,  9.81632653, 10.        ])
> ```

## 특별한 형태의 배열 생성

### np.zeros()

>  **모든 요소가 0인 배열 생성**
>
> `np.zeros(shape, dtype=float, ...)`
>
> `np.zeros((3,5)).reshape(5,3)`
>
> ```
> array([[0., 0., 0.],
>        [0., 0., 0.],
>        [0., 0., 0.],
>        [0., 0., 0.],
>        [0., 0., 0.]])
> ```

### np.ones()

> **모든 요소가 1인 배열 생성** 
>
> `np.ones(shape, dtype=None)`
>
> `np.ones((3,5), dtype=int)`
>
> ```
> array([[1, 1, 1, 1, 1],
>        [1, 1, 1, 1, 1],
>        [1, 1, 1, 1, 1]])
> ```

###  np.eye()

> **대각요소가 1인 배열 생성1**
>
> `np.eye(n, m, k=K, dtype=float)`
>
> `np.eye(3,4, k=2)`
>
> ```
> array([[0., 0., 1., 0.],
>        [0., 0., 0., 1.],
>        [0., 0., 0., 0.]])
> ```

###  np.identity()

> **대각요소가 1인 배열 생성2**
>
> `np.identity(n, dtype=자료형)`
>
> `np.identity(5, dtype=int)`
>
> ```
> array([[1, 0, 0, 0, 0],
>        [0, 1, 0, 0, 0],
>        [0, 0, 1, 0, 0],
>        [0, 0, 0, 1, 0],
>        [0, 0, 0, 0, 1]])
> ```

### np.empty()

> **초기화되지 않은 배열 생성**
>
> `np.empty(4)`
>
> ```
> array([0., 0., 0., 0.])
> ```

## astype()

> 배열의 데이터 타입 변환
>
> 바꿀수 없는 것은 오류가 나옴
>
>  `num_arr = str_arr.astype(dtype)`
>
> ` num_a1 = str_a1.astype('float32')`
>
> ```
> array([1.5     , 0.62    , 2.      , 3.14    , 3.141592]
> ```

## 난수 배열 생성

### random.rand()

> `random.rand([d0, d1, ..., dn])`
>
> - 0과 1 사이의 `실수` 난수를 갖는 NumPy 배열을 생성
> - rand(d0, d1, ..., dn)을 실행하면 (d0, d1, ..., dn)의 형태를 보이는 실수 난수 배열 생성
>
> `np.random.rand(2,3,4)`
>
> ```
> array([[[0.32320571, 0.81253569, 0.47599006, 0.06932435],
>         [0.66705447, 0.61810587, 0.32013262, 0.03288708],
>         [0.57588633, 0.93558938, 0.61371422, 0.4635101 ]],
> 
>        [[0.97524433, 0.20134363, 0.86962887, 0.68841211],
>         [0.23337261, 0.61820769, 0.10970224, 0.10675563],
>         [0.88698946, 0.42364217, 0.49028856, 0.91902302]]])
> ```

### random.randint()

> `random.randint([low,] high [,size])`
>
> - [low, high) 사이의 `정수` 난수를 갖는 NumPy 배열을 생성
> - size : (d0, d1, ..., dn) 형식으로 입력
>
> `np.random.randint(10, 20, size=(3,5))`
>
> ```
> array([[18, 19, 16, 19, 10],
>        [11, 12, 15, 10, 14],
>        [10, 10, 13, 17, 14]])
> ```

## array 연산

>* 기본 연산(합, 차, 곱, 나눗셈 등)
>
>* 기본적으로 동일한 크기의 array 간 연산 수행
>
>  `ex`
>
>  ```
>  arr1 = np.array([[1,3,4],[4,3,6]])
>  arr2 = np.arange(10,16).reshape(2,3)
>  ```

### 배열의 합

> `arr1 + arr2`
>
> ```
> array([[11, 14, 16],
>        [17, 17, 21]])
> ```

### 배열의 차

> `arr1 - arr2`
>
> ```
> array([[ -9,  -8,  -8],
>        [ -9, -11,  -9]])
> ```

### 배열의 곱

> `arr1 * arr2`
>
> ```
> array([[10, 33, 48],
>        [52, 42, 90]])
> ```

### 배열의 나눗셈

> `arr1 / arr2`
>
> ```
> array([[0.1       , 0.27272727, 0.33333333],
>        [0.30769231, 0.21428571, 0.4       ]])
> ```

### 배열의 스칼라 곱

> `arr2*2`
>
> ```
> array([[20, 22, 24],
>        [26, 28, 30]])
> ```

### 배열의 비교 연산

>`arr2 > 12`
>
>```
>array([[False, False, False],
>       [ True,  True,  True]])
>```

### 배열의 Broadcasting

> - 서로 크기가 다른 array들의 연산이 가능하도록 배열을 자동적으로 변환하여 연산 수행
> - 조건
>   - 두 배열 간의 연산에서 최소한 하나의 배열의 차원이 1인 경우(0번 축이든 1번 축이든; 1행이든 1열이든)
>   - 차원의 짝이 맞을 때(차원에 대해 축의 길이가 동일시)
>
> `ex)`
>
> ```
> arr1 =([[1, 3, 4],
>        [4, 3, 6]])
> arr3 = ([10,11,12])
> ```
>
> ```
> arr1 + arr3
> array([[11, 14, 16],
>        [14, 14, 18]])
> ```
>
> ```
> arr1 * 10
> array([[10, 30, 40],
>        [40, 30, 60]])
> ```
>
> ```
> array([[ 1,  9, 16],
>        [16,  9, 36]], dtype=int32)
> ```


##  통계를 위한 연산


> - 배열의 합, 평균, 표준편차, 분산, 최소값, 최대값, 누적합, 누적곱 등
> - https://numpy.org/doc/stable/reference/routines.statistics.html
>
> `ex)`
>
> `arr1 = np.arange(5)`
>
> ```
> array([0, 1, 2, 3, 4])
> ```

### 합과 (산술)평균 : sum(), mean()

> * `[arr1.sum(), arr1.mean()]`
>
>   * ```
>     [10, 2.0]
>     ```

### 표준편차와 분산 : std(), var()

> * `[arr1.std(), arr1.var()]`
>
>   * ```
>     [1.4142135623730951, 2.0]
>     ```

### 최소값과 최대값 : min(), max()

> * [arr1.min(), arr1.max()]
>
>   * ```
>     [0, 4]
>     ```

### 누적합과 누적곱

> `ex)`
>
> `arr2 = np.arange(1,5)`
>
> * 누적합 : cumsum()
>
> * arr2.cumsum()
>
>   * ```
>     array([ 1,  3,  6, 10], dtype=int32)
>     ```
>
> * 누적곱 : cumprod()
>
> * arr2.cumprod()
>
>   * ```
>     array([ 1,  2,  6, 24], dtype=int32)
>     ```

## 행렬 연산

> - 선형 대수(Linear algebra)를 위한 행렬(2차원 배열) 연산
> - 행렬 곱, 전치 행렬, 역행렬, 행렬식 등
>   - 행렬곱(matrix product) : A.dot(B) 혹은 np.dot(A,B)
>   - 전치행렬(transpose matrix) : A.transpose() 혹은 np.transpose(A)
>   - 역행렬(inverse matrix) : np.linalg.inv(A)
>   - 행렬식(determinant) : np.linalg.det(A)
>
> `ex)`
>
> `A = np.arange(1,5).reshape(2,2)`
>
> ```
> array([[1, 2],
>        [3, 4]])
> ```
>
> `B = np.array([3,2,0,1]).reshape(2,2)`
>
> ```
> array([[3, 2],
>        [0, 1]])
> ```

### **행렬의 곱**

> * `A.dot(B)`
>
>   * ```
>     array([[ 3,  4],
>            [ 9, 10]])
>     ```
>
> * `np.dot(A,B)`
>
>   * ```
>     array([[ 3,  4],
>            [ 9, 10]])
>     ```
>
> 

### **전치행렬**

> * `A.transpose()`
>
>   * ```
>     array([[1, 3],
>            [2, 4]])
>     ```
>
> * `np.transpose(A)`
>
>   * ```
>     array([[1, 3],
>            [2, 4]])
>     ```

### **역행렬**

> * `np.linalg.inv(A)`  역행렬(inverse)
>
>   * ```
>     array([[-2. ,  1. ],
>            [ 1.5, -0.5]])
>     ```
>
> * `np.linalg.det(A)`   행렬식(determinant)
>
>   * ```
>     -2.0000000000000004
>     ```
>
> * `np.dot(A, np.linalg.inv(A))`   A * inv(A) = I (단위행렬)
>
>   * ```
>     array([[1.00000000e+00, 1.11022302e-16],
>            [0.00000000e+00, 1.00000000e+00]])
>     ```

## Array 인덱싱(indexing)과 슬라이싱(Slicing)

> * 인덱싱(indexing) : 배열의 위치나 조건을 지정해 배열의 원소를 선택하는 것
> * 슬라이싱(slicing) : 범위를 지정해 배열의 원소를 선택하는 것
>   - : 연산자를 주로 사용

### 1차원 배열의 인덱싱

> * **배열명[위치]**
>
>   * 파이썬의 인덱싱과 동일
>   * 0번째로 시작함
>
> * **배열명[[위치1, 위치2, ... ,위치n]]**
>
>   1, 3, 4, 위치 : shape : (m, ) => 1차원, (m, n) => 2차원, (m, n, p) => 3차원 인덱스 [ ] : [m] => 1차원, [m,n] => 2차원, [m,n,p] => 3차원 arr1[[1,3,4] => 3차원 배열의 위치 1면 3행 4열 여러 인덱스의 요소드를 지정 : 리스트로 주어야 한다
>
> `ex)`
>
> `arr1 = np.arange(10)`
>
> ```
> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> ```
>
> * `arr1[3]`
>
>   * ```
>     3
>     ```
>
> * `arr1[[1,3,4]]`
>
>   * ```
>     array([1, 3, 4])
>     ```

### 2차원 배열의 인덱싱

> * **배열명[행위치, 열위치]**
>
> `ex)`
>
> `arr2 = np.arange(1,13).reshape(3,4)`
>
> ```
> array([[ 1,  2,  3,  4],
>        [ 5,  6,  7,  8],
>        [ 9, 10, 11, 12]])
> ```
>
> * `arr2[2,3]`  2차원의 array에서 인덱싱을 하기 위해선 2개의 인자를 입력/2행3열
>
>   * ```
>     12
>     ```
>
> * `arr2[0,0]=90` 0행0열 값 변경
>
>   * ```
>     array([[90,  2,  3,  4],
>            [ 5,  6,  7,  8],
>            [ 9, 10, 11, 12]])
>     ```

### **2차원배열명[행위치]**

> 2차원 배열에서 지정한 행 전체가 선택됨
>
> * `arr2[1]`
>
>   * ```
>     array([5, 6, 7, 8])
>     ```

### **2차원배열명[:,열위치]**

> 2차원 배열에서 지정한 열 전체 선택
>
> * `arr2[:,1]`
>
>   * ```
>     array([ 2,  6, 10])
>     ```

### 2차원 배열의 특정 행을 지정해서 행 전체를 변경

> * `arr2[1] = np.array([-5, 1, 10, 9])` 두번째 행 변경
>
>   * ```
>     array([[90,  2,  3,  4],
>            [-5,  1, 10,  9],
>            [ 9, 10, 11, 12]])
>     ```

### 배열명[[행위치1, ... , 행위치n],[열위치1,... ,열위치n]]

> * 지정한 (행위치1, 열위치1), (행위치2, 열위치2), ... ,(행위치n, 열위치n)의 원소를 가져옴
>
> * `arr2[[0,2],[0,1]]`
>
>   * ```
>     array([90, 10])
>     ```

### 배열명[조건]

> 배열에서 조건을 만족하는 원소만 선택
>
> * `arr2 > 10`   비교 연산
>
>   * ```
>     array([[ True, False, False, False],
>            [False, False, False, False],
>            [False, False,  True,  True]])
>     ```
>
> * `arr2[arr2 > 10]`    비교연산 결과를 인덱스로 지정
>
>   * ```
>     array([90, 11, 12])
>     ```
>
> * `arr2[arr2 % 2 == 0]`   짝수인 원소 선택
>
>   * ```
>     array([90,  2,  4, 10, 10, 12])
>     ```

### 1차원 배열의 슬라이싱(Slicing)

> **배열[시작위치:끝위치]**
>
> : 시작위치에서 끝위치-1 에 해당하는 배열의 원소를 반환
>
> `ex)`
>
> `arr1 =array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`
>
> * `arr1[3:9]` 3번째 요소부터 8번째 요소
>
>   * ```
>     array([3, 4, 5, 6, 7, 8])
>     ```
>
> * **배열[start:end+1:step]**
>
>   * start에서 end 범위까지의 자료 중 step 간격의 인덱스를 지정
>
>   * `arr1[3::2]`
>
>     * ```
>       array([3, 5, 7, 9])
>       ```
>
> * **배열[:끝위치]**
>
>   * 처음부터 '끝위치-1' 원소 반환
>
>   * `arr1[:3]`
>
>     * ```
>       array([0, 1, 2])
>       ```
>
> * **배열[시작위치:]**
>
>   * 시작위치부터 마지막 원소까지 반환
>
>   * `arr1[2:]`
>
>     * ```
>       array([2, 3, 4, 5, 6, 7, 8, 9])
>       ```
>
> * **배열[:]**
>
>   * 모든 원소 반환
>
>   * `arr1[:]`
>
>     * ```
>       array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>       ```

### 2차원 배열의 슬라이싱

> **배열[행시작위치:행끝위치, 열시작위치:열끝위치]**
>
> `ex)`
>
> `arr2`
>
> ```
> array([[90,  2,  3,  4],
>     [-5,  1, 10,  9],
>     [ 9, 10, 11, 12]])
> ```
>
> `arr3 = np.arange(10,100, 10).reshape(3,3)`
>
> ```
> array([[10, 20, 30],
>        [40, 50, 60],
>        [70, 80, 90]])
> ```
>
> * `arr2[1:3, 1:3]`
>
>   * ```
>     array([[ 1, 10],
>            [10, 11]])
>     ```
>
> * `배열[행위치][열시작위치:열끝위치]`
>
>   * 특정 행을 선택한 후 열을 슬라이싱
>
>   * `arr3[1][:2]`
>
>     * ```
>       array([40, 50])
>       ```
>
>   * `arr3[2][1]`
>
>     * ```
>       80
>       ```
>
> * **슬라이싱 된 배열에 값을 지정**
>
>   * `arr3[:2, 1:3]=np.array([[1,3],[4,1]])`   0~1행, 1~2열의 요소 변경
>
>     * ```
>       array([[10,  1,  3],
>              [40,  4,  1],
>              [70, 80, 90]])
>       ```

## Array boolean 인덱싱(Mask)

> - 다차원의 인덱싱을 응용하여 boolean 인덱싱
> - boolean인덱싱을 통해 만들어낸 array를 통해 원하는 행 또는 열의 값만 뽑아냄
> - 가리고 싶은 부분은 가리고, 원하는 요소만 꺼냄
>
> `ex)`
>
> `names = np.array(['Beomwoo','Beomwoo','Kim','Joan','Lee','Beomwoo',
>                   'Park','Beomwoo'])`
>
> ```
> array(['Beomwoo', 'Beomwoo', 'Kim', 'Joan', 'Lee', 'Beomwoo', 'Park',
>        'Beomwoo'], dtype='<U7')
> ```
>
> `data = np.random.randn(8,4)`
>
> ```
> array([[-0.54339928, -0.08180309, -0.74706651,  1.55631954],
>        [ 0.85140869,  1.38644708, -1.31231915,  1.19067665],
>        [-0.41921348, -0.37893179, -0.16960781,  0.02524215],
>        [-1.06175977, -2.6208565 ,  0.4117048 , -0.1189974 ],
>        [-1.57744864, -0.03630832, -0.80323474, -0.99038655],
>        [ 0.89326685, -2.07554253, -1.50895431, -0.33879087],
>        [-0.39944221, -0.70795638,  2.07549963, -1.54695463],
>        [ 1.18934853, -0.65885955,  0.04311649, -0.45962017]])
> ```
>
> * `names_mask_Beomwoo=(names == 'Beomwoo')`
>
>   * ```
>     array([ True,  True, False, False, False,  True, False,  True])
>     ```
>
> * `data[names_mask_Beomwoo, :]`
>
>   * 요소가 Beomwoo인 항목의 위치와 같은 행의 자료 가져오기
>
>   * data[names_mask_Beomwoo] : 같은 결과
>
>   * Beomwoo 의 위치는 위에서 0,1,5,7
>
>   * ```
>     array([[-0.54339928, -0.08180309, -0.74706651,  1.55631954],
>            [ 0.85140869,  1.38644708, -1.31231915,  1.19067665],
>            [ 0.89326685, -2.07554253, -1.50895431, -0.33879087],
>            [ 1.18934853, -0.65885955,  0.04311649, -0.45962017]])
>     ```
>
> * data[(names == 'Kim') | (names == 'Park')]
>
>   * 논리 연산을 응용하여, 요소가 Kim 또는 Park인 행의 데이터만 꺼내기
>
>   * ```
>     array([[ 0.0896273 , -0.58352658, -0.94132764, -0.14960025],
>            [-1.28145415,  0.27909961, -2.12055814, -0.51304004]]
>     ```

## array에 적용되는 다양한 함수

>  하나의 array에 적용되는 함수
>
### random.randn(d0,d1,.., dn) : 표준정규난수 생성
>
>   * `data = np.random.randn(5,3)`
>
>   * ```
>      array([[ 0.40696204, -0.17040153, -0.06180152],
>             [ 0.57448732,  0.47817841,  0.7673736 ],
>             [-1.48047862,  0.43335867,  0.26868707],
>             [ 0.59144634, -3.05878513,  1.01023448],
>             [ 2.13966335, -1.88761582, -1.41473855]])
>      ```
>
### 수학 관련 함수
>
>   * 제곱근, 절대값, 삼각함수, 지수로그함수, 반올림함수 등
>
>   * 각 성분의 절대값 계산하기
>
>     * `np.abs(data)`
>
>       * ```python
>          array([[0.40696204, 0.17040153, 0.06180152],
>                 [0.57448732, 0.47817841, 0.7673736 ],
>                 [1.48047862, 0.43335867, 0.26868707],
>                 [0.59144634, 3.05878513, 1.01023448],
>                 [2.13966335, 1.88761582, 1.41473855]])
>          ```
>
>   * 각 성분의 제곱근 계산하기
>
>     * `np.sqrt(np.abs(data))`
>
>       * ```
>          array([[0.63793577, 0.4127972 , 0.24859911],
>                 [0.75794942, 0.69150445, 0.87599863],
>                 [1.2167492 , 0.65829983, 0.51835034],
>                 [0.76905548, 1.74893829, 1.00510422],
>                 [1.46275881, 1.37390532, 1.18942783]])
>          ```
>
>   * 각 성분의 제곱 계산하기
>
>     * `np.square(data)`
>
>       * ```
>          array([[1.65618106e-01, 2.90366808e-02, 3.81942732e-03],
>                 [3.30035682e-01, 2.28654588e-01, 5.88862234e-01],
>                 [2.19181695e+00, 1.87799736e-01, 7.21927424e-02],
>                 [3.49808769e-01, 9.35616647e+00, 1.02057371e+00],
>                 [4.57815924e+00, 3.56309350e+00, 2.00148518e+00]])
>          ```
>    
### 지수 함수
>
>    * 각 성분을 자연대수 e의 지수로 삼은 값을 계산하기
>
>    * `np.exp(data)`
>
>      * ```
>        array([[1.50224709, 0.84332613, 0.94006946],
>               [1.77621966, 1.61313325, 2.15410128],
>               [0.22752876, 1.54242934, 1.30824569],
>               [1.80659948, 0.04694469, 2.74624489],
>               [8.49657675, 0.15143242, 0.24298913]])
>        ```
>

### 로그함수

> - 자연로그 : log()
>
>   - `np.log(abs(data))`
>
>     - ```
>       array([[-0.89903535, -1.7695977 , -2.78382739],
>              [-0.55427725, -0.73777138, -0.26478151],
>              [ 0.39236543, -0.83618956, -1.31420788],
>              [-0.52518432,  1.11801782,  0.01018247],
>              [ 0.7606485 ,  0.63531456,  0.34694475]])
>       ```
>
> - 상용로그 : log10()
>
>   - `np.log10(abs(data))`
>
>     - ```
>       array([[-0.39044609, -0.76852651, -1.20900087],
>              [-0.24071955, -0.32041004, -0.11499315],
>              [ 0.17040214, -0.36315251, -0.57075323],
>              [-0.22808465,  0.48554897,  0.00442219],
>              [ 0.33034545,  0.27591361,  0.15067619]])
>       ```
>
> - 밑이2인 로그 : log2()
>
>   - `np.log2(abs(data))`
>
>     - ```
>       array([[-1.29703385, -2.55298982, -4.01621397],
>              [-0.79965304, -1.06437912, -0.38199897],
>              [ 0.56606366, -1.20636653, -1.89600119],
>              [-0.75768082,  1.61295877,  0.01469019],
>              [ 1.09738382,  0.91656517,  0.50053547]])
>       ```

### 각 성분의 부호 계산 : sign()

> +인 경우 1, -인 경우 -1, 0인 경우 0
>
> * `np.sign(data)`
>
>   * ```
>     array([[ 1., -1., -1.],
>            [ 1.,  1.,  1.],
>            [-1.,  1.,  1.],
>            [ 1., -1.,  1.],
>            [ 1., -1., -1.]])
>     ```

### **반올림 함수**

> 각 성분의 소수 첫 번째 자리에서 내림한 값을 계산하기
>
> * np.floor(data)
>
>   * ```
>     array([[ 0., -1., -1.],
>            [ 0.,  0.,  0.],
>            [-2.,  0.,  0.],
>            [ 0., -4.,  1.],
>            [ 2., -2., -2.]])
>     ```

### NaN 여부 확인

> * 각 성분이 NaN인 경우 True를, 아닌 경우 False를 반환하기
>
>   * `np.isnan(data)`
>
>     * ```
>       array([[False, False, False],
>              [False, False, False],
>              [False, False, False],
>              [False, False, False],
>              [False, False, False]])
>       ```
>
> * 로그변환한 배열 중 Nan 확인
>
>   * `np.isnan(np.log(data))`
>
>     * ```
>       array([[False,  True,  True],
>              [False, False, False],
>              [ True, False, False],
>              [False,  True, False],
>              [False,  True,  True]])
>       ```

### 무한대(inf) 확인

> 각 성분이 무한대인 경우 True를, 아닌 경우 False를 반환하기
>
> * `np.isinf(data)`
>
>   * ```
>     array([[False, False, False],
>            [False, False, False],
>            [False, False, False],
>            [False, False, False],
>            [False, False, False]])
>     ```

### 삼각함수

> 각 성분에 대해 삼각함수 값을 계산하기(cos, cosh, sin, sinh, tan, tanh)
>
> * cos() 
>
>   * `np.cos(data)`
>
>     * ```
>       array([[ 0.91832755,  0.98551676,  0.99809089],
>              [ 0.839471  ,  0.88783463,  0.71973652],
>              [ 0.09019496,  0.90756049,  0.96412026],
>              [ 0.83013512, -0.99657342,  0.53166214],
>              [-0.53867785, -0.31154593,  0.1554251 ]])
>       ```
>
> * tan()
>
>   * `np.tan(data)`
>
>     * ```
>       array([[  0.43102412,  -0.17207021,  -0.06188032],
>              [  0.64731775,   0.51829772,   0.96458536],
>              [-11.041904  ,   0.46269242,   0.27534516],
>              [  0.67165241,   0.08299732,   1.59303526],
>              [ -1.56403652,   3.0500514 ,  -6.35577943]])
>       ```

### Sums, products, differences함수

> * 전체 성분의 합을 계산
>
>   * `np.sum(data)`
>
>     * ```
>       -1.4034298993890293
>       ```
>
> * 같은 열을 갖는 행의 요소들을 합한 결과(axis=0)
>
>   * `np.sum(data, axis=0)`
>
>     * ```
>       array([ 2.23208043, -4.20526541,  0.56975508])
>       ```
>
> * 같은 행을 갖는 열의 요소들을 합한 결과(axis=1)
>
>   * `np.sum(data, axis=1)`
>
>     * ```
>       array([ 0.174759  ,  1.82003932, -0.77843288, -1.45710431, -1.16269103])
>       ```

### 평균(mean), 표준편차(std), 분산(var)

> * 전체 성분의 평균 계산
>
>   * `np.mean(data)`
>
>     * ```
>       -0.09356199329260195
>       ```
>
> * 전체 성분의 표준편차 계산
>
>   * `np.std(data)`
>
>     * ```
>       1.2789530957085065
>       ```

### 최대값(max), 최소값(min)

> 전체 성분의 최소값, 최대값이 위치한 인덱스를 반환(argmin, argmax)
>
> * `[np.argmax(data), np.argmin(data)]`  =[np.max(data), np.min(data)]
>
>   * ```
>     [12, 10]
>     ```

### 누적합(cumsum), 누적곱(cumprod)

> 맨 처음 성분부터 각 성분까지의 누적합 또는 누적곱을 계산(cumsum, cumprod)
>
> * `np.cumsum(data)`
>
>   * ```
>     array([ 0.40696204,  0.23656052,  0.174759  ,  0.74924632,  1.22742473,
>             1.99479832,  0.5143197 ,  0.94767837,  1.21636544,  1.80781178,
>            -1.25097335, -0.24073887,  1.89892448,  0.01130865, -1.4034299 ])
>     ```
>
> * `np.cumprod(data)`
>
>   * ```
>     array([ 4.06962045e-01, -6.93469543e-02,  4.28574687e-03,  2.46210724e-03,
>             1.17732652e-03,  9.03449280e-04, -1.33753735e-03, -5.79633403e-04,
>            -1.55740002e-04, -9.21118535e-05,  2.81750368e-04,  2.84633937e-04,
>             6.09020803e-04, -1.14959730e-03,  1.62637963e-03])
>     ```

### 정렬

> * 전체 성분에 대해서 오름차순으로 정렬
>
>   * `np.sort(data)`
>
>     * ```
>       array([[-0.17040153, -0.06180152,  0.40696204],
>              [ 0.47817841,  0.57448732,  0.7673736 ],
>              [-1.48047862,  0.26868707,  0.43335867],
>              [-3.05878513,  0.59144634,  1.01023448],
>              [-1.88761582, -1.41473855,  2.13966335]])
>       ```
>
> * 전체 성분에 대해서 [::-1]를 적용 : 정렬 후 마지막행부터 표시
>
>   * `np.sort(data)[::-1]`
>
>     * ```
>       array([[-1.88761582, -1.41473855,  2.13966335],
>              [-3.05878513,  0.59144634,  1.01023448],
>              [-1.48047862,  0.26868707,  0.43335867],
>              [ 0.47817841,  0.57448732,  0.7673736 ],
>              [-0.17040153, -0.06180152,  0.40696204]])
>       ```

### 두 개의 array에 적용되는 함수

> `ex)`
>
> `data1 = np.random.randn(5,3)`
>
> ```
> [[-0.11873631 -0.15606184  2.3405258 ]
>  [ 0.48594021  1.20748378 -0.13777945]
>  [ 1.30323514 -0.04170429  1.34485798]
>  [ 1.27803686 -1.37663276 -1.02904443]
>  [ 0.34449623  0.90103236  0.44644461]]
> ```
>
> `data2 = np.random.randn(5,3)`
>
> ```
> [[-1.5249542  -0.64878847  1.60669549]
>  [-0.98875613 -0.79195453  0.88476398]
>  [-0.89016598  2.29047591 -1.48256026]
>  [-0.39800716 -0.66599419  2.01860266]
>  [-0.22311217 -0.22524493  0.56931033]]
> ```

#### 두 개의 array에 대해 동일한 위치의 성분끼리 연산

> add(), subtract(), multiply(), divide()
>
> - 두 배열의 합
>
>   - `np.add(data1, data2)`
>
>     - ```
>       array([[-1.64369051, -0.80485031,  3.94722129],
>              [-0.50281592,  0.41552925,  0.74698452],
>              [ 0.41306915,  2.24877162, -0.13770228],
>              [ 0.8800297 , -2.04262694,  0.98955822],
>              [ 0.12138406,  0.67578743,  1.01575495]])
>       ```
>
> - 두 배열의 차
>
>   - `np.subtract(data1, data2)`
>
>     - ```
>       array([[ 1.40621789,  0.49272662,  0.73383031],
>              [ 1.47469634,  1.99943832, -1.02254343],
>              [ 2.19340112, -2.33218019,  2.82741824],
>              [ 1.67604402, -0.71063857, -3.04764709],
>              [ 0.5676084 ,  1.12627729, -0.12286572]])
>       ```
>
> - 두 배열의 곱
>
>   - `np.multiply(data1, data2)`
>
>     - ```
>       array([[ 0.18106743,  0.10125112,  3.76051225],
>              [-0.48047637, -0.95627225, -0.1219023 ],
>              [-1.16009559, -0.09552266, -1.993833  ],
>              [-0.50866782,  0.91682941, -2.07723182],
>              [-0.0768613 , -0.20295297,  0.25416553]])
>       ```
>
> - 두 배열의 나누기
>
>   - `np.divide(data1, data2)`
>
>     - ```
>       array([[ 0.07786221,  0.24054349,  1.45673266],
>              [-0.4914662 , -1.52468827, -0.15572453],
>              [-1.4640361 , -0.01820769, -0.90711859],
>              [-3.21109012,  2.0670342 , -0.50978058],
>              [-1.54404947, -4.00023371,  0.78418499]])
>       ```
>
> - 최대값 또는 최소값 계산 : maximum(), minimum()
>
>   - 두 개의 array에 대해 동일한 위치의 성분끼리 비교
>
>   - `np.maximum(data1, data2)`
>
>     - ```
>       array([[-0.11873631, -0.15606184,  2.3405258 ],
>              [ 0.48594021,  1.20748378,  0.88476398],
>              [ 1.30323514,  2.29047591,  1.34485798],
>              [ 1.27803686, -0.66599419,  2.01860266],
>              [ 0.34449623,  0.90103236,  0.56931033]])
>       ```
>
>   - `np.minimum(data1, data2)`
>
>     - ```
>       array([[-1.5249542 , -0.64878847,  1.60669549],
>              [-0.98875613, -0.79195453, -0.13777945],
>              [-0.89016598, -0.04170429, -1.48256026],
>              [-0.39800716, -1.37663276, -1.02904443],
>              [-0.22311217, -0.22524493,  0.44644461]])
>       ```

