

# Pandas

> - 서로 다른 유형의 데이터를 공통된 포맷으로 정리하는 것
> - 행과 열로 이루어진 2차원 데이터프레임을 처리 할 수 있는 함수제공 목적
> - 실무 사용 형태 : 데이터 프레임
> - 사용 모듈 `import pandas as pd`
> - Series 데이터
> - 데이터 프레임

## Series

> - pandas의 기본 객체 중 하나
> - numpy의 ndarray를 기반으로 인덱싱 기능을 추가하여 1차원 배열을 나타냄
> - index를 지정하지 않을 시, 기본적으로 ndarray와 같이 0-based 인덱스 생성, 지정할 경우 명시적으로 지정된 index를 사용
> - 같은 타입의 0개 이상의 데이터를 가질 수 있음
> - 자료구조: 시리즈
>   - 데이터가 순차적으로 나열된 1차원 배열 형태
>   - 인덱스(index)와 데이터 값(value)이 일대일로 대응
>   - 딕셔너리와 비슷한 구조 : {key(index):value}
> - 시리즈의 인덱스
>   - 데이터 값의 위치를 나타내는 이름표 역할
> - 시리즈 생성 : 판다스 내장함수인 Series()이용
>   - 리스트로 시리즈 만들기
>   - 딕셔너리로 시리즈 만들기
>   - 튜플로 시리즈 만들기
>   - `pd.Series(seq_data)`함수 이용
>     - seq_data : 리스트, 딕셔너리, 튜플 타입 데이터
>     - index는 기본적으로 0부터 자동적으로 생성

### Series 생성

####  **리스트로 시리즈 만들기**
>
>   * `s2 = pd.Series('A B C'.split())`
>
>     * ```
>       0    A
>       1    B
>       2    C
>       dtype: object
>       ```
>
>   * pd.Series(1차원 배열 : 리스트)
>
#### 범위를 시리즈의 value 생성하는 데 사용하기
>
>   * range() / np.arange() 함수 사용
>
>   * `s = pd.Series(range(10,14))`
>
>     * ```
>       0    10
>       1    11
>       2    12
>       3    13
>       dtype: int64
>       ```
>
>   * `s = pd.Series(np.arange(200))`
>
>     * ```
>       0        0
>       1        1
>       2        2
>       3        3
>       4        4
>             ... 
>       195    195
>       196    196
>       197    197
>       198    198
>       199    199
>       Length: 200, dtype: int32
>       ```
>
#### 결측값을 포함해서 시리즈 만들기
>
>   * 결측값 NaN - numpy 라는 모듈에서 생성할 수 있음
>
>   * 결측값 생성 위해서는 numpy 모듈 import
>
>   * `s = pd.Series([1,2,3,np.nan,6,8])`
>
>     * ```
>       0    1.0
>       1    2.0
>       2    3.0
>       3    NaN
>       4    6.0
>       5    8.0
>       dtype: float64
>       ```

#### 인덱스 명시해서 시리즈 만들기

> * 숫자 인덱스 지정
>
>   * `s1 = pd.Series([10,20,30], index=[1,2,3])`
>
>     * ```
>       1    10
>       2    20
>       3    30
>       dtype: int64
>       ```
>
> * 문자 인덱스 지정
>
>   * `s2 = pd.Series([95, 100, 88], index=['홍길동','이몽룡','성춘향'])`
>
>     * ```
>       홍길동     95
>       이몽룡    100
>       성춘향     88
>       dtype: int64 
>       ```

#### 인덱스 활용

> * 시리즈의 index
>
>   * 시리즈의 index는 index 속성으로 접근 : **시리즈.index**
>
>   * `s2.index`
>
>     * ```
>       Index(['홍길동', '이몽룡', '성춘향'], dtype='object')
>       ```
>
> * **시리즈.index.name 속성**
>
>   * 시리즈의 인덱스에 이름을 붙일 수 있음
>
>   * `s.index.name = '도시'`
>
>     * ```
>       도시
>       서울    9904312
>       부산    3448737
>       인천     289045
>       대구    2466052
>       dtype: int64
>       ```

#### 시리즈의 값

> * numpy 자료구조 : 1차원 배열
>
> * values 속성으로 접근 : **시리즈.values**
>
>   * `s.values`
>
>     * ```
>       array([10, 11, 12, 13], dtype=int64)
>       ```

#### 시리즈.name 속성

> * 시리즈 데이터에 이름을 붙일 수 있음
>
> * name 속성은 값의 의미 전달에 사용
>
>   * `s.name = '인구수'`
>
>     * ```
>       도시
>       서울    9904312
>       부산    3448737
>       인천     289045
>       대구    2466052
>       Name: 인구수, dtype: int64
>       ```

### 시리즈 인덱싱(indexing)

> 인덱싱 : 데이터에서 특정한 데이터를 골라내는 것
>
> #### 시리즈의 인덱싱 종류
>
> 1. 정수형 위치 인덱스(integer position)
>
> 2. 인덱스 이름(index name) 또는 인덱스 라벨(index label)
>
>    - 인덱스 별도 지정하지 않으면 0부터 시작하는 정수형 인덱스가 지정됨
>
> 3. 원소접근
>
>    - 정수형 인덱스 : 숫자 s[0]
>    - 문자형 인덱스 : 문자 s['인천'] , s.인천 

####  정수형 인덱스 접근

> * `s[0]`
>
>   * ```
>     Index(['서울', '부산', '인천', '대구'], dtype='object', name='도시')
>     9904312
>
>   * 인덱스 서울의 value가 접근

#### 문자형 인덱스 접근

> * `s['서울']`
>
>   * ```
>     9904312
>     ```

#### 위치 인덱스와 문자 인덱스를 동시에 접근

> * `s[2], s['대구']`
>
>   * ```
>     (289045, 2466052)
>     ```

#### 리스트 이용 인덱싱

> * 자료의 순서를 바꾸거나 특정자료 여러개를 선택할 수 있다.
>
> * 인덱스값 여러 개를 이용해 접근시 [ ]안에 넣는다
>
>   * `s[['서울','대구']]`
>
>     * ```
>       서울    9904312
>       대구    2466052
>       dtype: int64
>       ```
>
>   * `s[[1,2]]`
>
>     * ```
>       부산    3448737
>       인천     289045
>       dtype: int64
>       ```

#### 문자 인덱스를 이용한 인덱싱

> * 연산자를 이용하여 접근가능 : 객체명.문자인덱스명
>
> * 인덱스를 문자값으로 지정한 시리즈
>
>   * `s.서울`
>
>     * ```
>       9904312
>       ```
>
>   * `s1.a`    s1 = pd.Series(range(3), index=['a','b','c'])
>
>     * ```
>       0
>       ```

### 시리즈 슬라이싱(slicing)

> - 정수형 위치 인덱스를 사용한 슬라이싱
>
>   - 시리즈[start : stop+1]
>
>   - `s[1:3]`
>
>     - ```
>       부산    3448737
>       인천     289045
>       dtype: int64
>       ```
>
> - 문자(라벨)인덱스 이용 슬라이싱
>
>   - 시리즈['시작라벨' : '끝라벨'] : 표시된 라벨 범위 모두 추출
>
>   - `s['부산':'대구']`
>
>     - ```
>       부산    3448737
>       인천     289045
>       대구    2466052
>       dtype: int64
>       ```

### 인덱스 통한 시리즈 데이터 업데이트

> * `s['서울']=10000000`   9904312=>10000000 값이 바뀜
>
>   * ```
>     서울    10000000
>     부산     3448737
>     인천      289045
>     대구     2466052
>     dtype: int64
>     ```

### 인덱스 재사용

> * `s1 = pd.Series(np.arange(4), s.index)`  s의 index=["서울","부산","인천","대구"]) 
>
>   * ```
>     서울    0
>     부산    1
>     인천    2
>     대구    3
>     dtype: int32
>     ```

### 시리즈 연산

#### 벡터화 연산

> - numpy 배열처럼 pandas의 시리즈도 벡터화 연산 가능
>
> - 벡터화 연산이란 집합적 자료형의 원소 각각을 독립적으로 계산을 진행하는 방법
>
>   - 단, 연산은 시리즈의 값에만 적용되며 인덱스 값은 변경 불가
>
> - 시리즈의 모든 value에 대하여 각각 연산을 진행
>
> - `pd.Series([1,2,3]) +4`  시리즈와 스칼라의 합
>
>   - ```
>     0    5
>     1    6
>     2    7
>     dtype: int64
>     ```
>
> - `s/1000000`
>
>   - ```
>     서울    10.000000
>     부산     3.448737
>     인천     0.289045
>     대구     2.466052
>     dtype: float64
>     ```

#### 벡터화 인덱싱 : Boolean selection

> - boolean Series가 []와 함께 사용되면 True 값에 해당하는 값만 새로 반환되는 Series객체에 포함됨
>
> - 다중조건의 경우, &(and), |(or)를 사용하여 연결 가능
>
>   - `s[(s > 2500000) & (s < 5000000)]`   =같은 식 `(s > 25e5) & (s < 50e5)`
>
>     - s 시리즈 값 중 2500000 보다 크고 5000000 보다 작은 원소를 추출
>
>     - 각 원소의 값 모두 각각 조건식을 확인 하여 결과가 True인 원소만 추출
>
>     - ```
>       부산    3448737
>       dtype: int64
>       ```
>
>   - `s0.index > 5`  s0 = pd.Series(np.arange(10), np.arange(10)+1)
>
>     - ```
>       array([False, False, False, False, False,  True,  True,  True,  True,
>               True])
>       ```

#### 두 시리즈간의 연산

> - 시리즈간의 연산은 같은 인덱스를 찾아 연산을 진행
>
> - 동일한 인덱스는 연산을 진행하고 나머지 인덱스는 연산처리가 불가 해 NaN 값 처리
>
> - 시리즈 + 시리즈
>
>   - 같은 인덱스를 찾아 + 연산을 진행
>
>   - `num_s1 + num_s2`
>
>   - num_s1 = pd.Series([1,2,3,4],index=['a','b','c','d'])
>
>   - num_s2 = pd.Series([5,6,7,8],index=['b','c','d','a'])
>
>     - ```
>       a     9
>       b     7
>       c     9
>       d    11
>       dtype: int64
>       ```
>
> - 시리즈 + 시리즈
>
>   - 동일한 인덱스는 연산을 진행하고 나머지 인덱스는 연산처리가 불가 해 NaN 값 처리
>
>   - `num_s3 + num_s4`
>
>   - num_s3 = pd.Series([5,6,7,8],index=['e','b','f','g'])
>
>   - num_s4 = pd.Series([1,2,3,4],index=['a','b','c','d'])
>
>     - ```
>       a    NaN
>       b    8.0
>       c    NaN
>       d    NaN
>       e    NaN
>       f    NaN
>       g    NaN
>       dtype: float64
>       ```
>
> - 시리즈 - 시리즈
>
>   - num_s3 - num_s4
>
>     - ```
>       a    NaN
>       b    4.0
>       c    NaN
>       d    NaN
>       e    NaN
>       f    NaN
>       g    NaN
>       dtype: float64
>       ```
>
> - 시리즈의 values 속성을 이용한 연산
>
>   - values 속성을 사용하면 시리즈의 형태가 사라지므로 동일 위치 원소들끼리 연산
>
>   - 시리즈.values 는 array 형태 반환
>
>   - `num_s3.values - num_s4.values`
>
>     - ```
>       array([4, 4, 4, 4], dtype=int64)
>       ```
>
> - **in 연산자/ for 반복문 사용**
>
>   - 시리즈 객체는 라벨(문자)에 의해 인덱싱이 가능
>
>   - 실질적으로는 라벨을 key로 가지는 딕셔너리 형과 같다고 볼 수 있음
>
>   - 딕셔너리에서 제공하는 대부분의 연산자 사용 가능
>
>     - in 연산자 : T / F
>     - for 루프를 통해 각 원소의 key와 value에 접근
>
>   - `'서울' in s`
>
>     - ```
>       True
>       ```
>
>   - `list(s.items())`
>
>     - ```
>       [('서울', 10000000), ('부산', 3448737), ('인천', 289045), ('대구', 2466052)]
>       ```
>   
>   - ⬇⬇for 이용 시리즈 각 원소 출력⬇⬇
>   
>   - ```
>     for k, v in s.items():
>         print(f'{k}={v}')
>     ```
>   
>     - ```
>       서울=10000000
>       부산=3448737
>       인천=289045
>       대구=2466052
>       ```

### 딕셔너리로 시리즈 만들기

> - `Series({key1:value1, key2:value2, key3:value3, ... })`
>
>   - 인덱스 -> key
>   - 값 -> value
>
> - `city = {'서울':9631482,'부산':3393191,'인천':2632035,'대전':1490158}
>   s = pd.Series(city)`
>
>   - ```
>     서울    9631482
>     부산    3393191
>     인천    2632035
>     대전    1490158
>     dtype: int64
>     ```

#### 딕셔너리 기반으로 생성한 시리즈 인덱스 설정

> - 딕셔너리의 원소는 순서를 갖지 않는다.
>
>   - 딕셔너리로 생성된 시리즈의 원소도 순서가 보장되지 않는다.
>
>   - 만약 순서를 보장하고 싶으면 인덱스를 리스트로 지정해야 한다.
>
>   - `s = pd.Series(city, index=['부산','인천','서울','대전'])`
>
>     - ```
>       부산    3393191
>       인천    2632035
>       서울    9631482
>       대전    1490158
>       dtype: int64
>       ```

### 시리즈 데이터의 갱신,추가, 삭제

> - 시리즈 데이터 갱신
>
> - `s['부산']= 1630000`
>
>   - ```
>     부산    1630000
>     인천    2632035
>     서울    9631482
>     대전    1490158
>     dtype: int64
>     ```
>
> - 시리즈 데이터 삭제
>
> - `del s['부산']`
>
>   - ```
>     인천    2632035
>     서울    9631482
>     대전    1490158
>     dtype: int64
>     ```
>
> - 시리즈 데이터 추가
>
> - `s['대구']=1875000`
>
>   - ```
>     인천    2632035
>     서울    9631482
>     대전    1490158
>     대구    1875000
>     dtype: int64
>     ```

### Series 함수

> `ex)`
>
> `s1 = pd.Series([1, 1, 2, 1, 2, 2, 2, 1, 1, 3, 3, 4, 5, 5, 7, np.NaN])`
>
> - size : 시리즈 원소 개수 반환
>
>   - `s1.size`
>
>     - ```
>       16
>       ```
>
> - shape : 튜플형태로 shape 반환
>
>   - `s1.shape`
>
>     - ```
>       (16,)
>       ```
>
> - unique(): 유일한 값만 ndarray로 반환
>
>   - `s1.unique()`
>
>     - ```
>       array([ 1.,  2.,  3.,  4.,  5.,  7., nan])
>       ```
>
> - count() : NaN을 제외한 개수를 반환
>
>   - `s1.count()`
>
>     - ```
>       15
>       ```
>
> - mean() : NaN을 제외한 평균
>
>   - numpy의 1차원 데이터 생성하고 평균을 계산
>
>   - 시리즈의 경우 평균은 Nan을 제외하고 계산
>
>   - `s1.mean()`
>
>     - ```
>       2.6666666666666665
>       ```
>     
>   - `a.mean()`   a = np.array([2, 2, 2, 2, np.NaN])
>   
>     - ```
>       nan
>       ```
>   
>   
>     - `b.mean()`    b = pd.Series(a)
>   
>   
>       - ```
>         2.0
>         ```
>
>
> - value_counts() : NaN을 제외하고 각 값들의 빈도를 반환
>
>
>   - `s1.value_counts()`
>
>   - 각 원소들의 그룹별 개수를 셈(빈도계산)
>
>
>     - ```
>       1.0    5
>       2.0    4
>       3.0    2
>       5.0    2
>       4.0    1
>       7.0    1
>       dtype: int64
>       ```

### 날짜 인덱스를 이용하여 시리즈 생성

> - 날짜 인덱스를 이용하여 시리즈 만들기
>
> - 날짜 표시 :'년-월-일' 형태의 문자열로 표시
>
>   - ```
>     index_date = ['2021-10-07','2021-10-08','2021-10-09','2021-10-10']
>     
>     s = pd.Series([200, 195, np.nan, 205], index=index_date)
>     s
>     ```
>
>     - ```
>       2021-10-07    200.0
>       2021-10-08    195.0
>       2021-10-09      NaN
>       2021-10-10    205.0
>       dtype: float64
>       ```

#### 날짜 생성 함수 : date_range()

> - 판다스 패키지의 date_range 함수 (날짜생성)
>
> - `pd.date_range(start=None, end=None, periods=None, freq='D')`
>
>   - start : 시작날짜
>   - end : 끝날짜
>   - periods : 날짜 생성기간
>   - freq : 날짜 생성 주기, 기본값은 'D' (Day)
>   - start는 필수 옵션/end나 periods는 둘 중 하나가 있어야 함
>
>   **freq 옵션**
>
> - 일별 간격으로 날짜 생성 freq입력하지 않을시
>
>   - `pd.date_range(start='2021-10-01', end='2021-10-20', freq='3D')`
>
>     - ```
>       DatetimeIndex(['2021-10-01', '2021-10-04', '2021-10-07', '2021-10-10',
>                      '2021-10-13', '2021-10-16', '2021-10-19'],
>                     dtype='datetime64[ns]', freq='3D')
>       ```
>
> - 주간격으로 날짜 생성
>
>   - 지정한 일자가 포함된 주의 요일 시작 일자 기준으로 일주일 주기로 생성
>
>   - freq='W' : 일요일 기준으로 일주일 주기로 생성
>
>   - freq='W-MON' : 월요일 기준으로 일주일 주기로 생성
>
>   - `pd.date_range(start='2021-10-01', end='2021-10-20', freq='W')`
>
>     - ```
>       DatetimeIndex(['2021-10-03', '2021-10-10', '2021-10-17'], dtype='datetime64[ns]', freq='W-SUN')
>       ```
>
> - 월간격으로 날짜 생성
>
>   - freq='M' : 월말 날짜 기준 주기
>
>   - freq='BM' : 업무 월말 날짜 기준 주기
>
>   - freq='MS' : 월초 날짜 기준 주기
>
>   - `pd.date_range(start='2021-10-01', periods=4 , freq='M')`
>
>     - ```
>       DatetimeIndex(['2021-10-31', '2021-11-30', '2021-12-31', '2022-01-31'], dtype='datetime64[ns]', freq='M')
>       ```
>
> - 분기별 주기로 날짜 생성
>
>   - freq = Q : 분기 끝 날짜 기준 주기
>
>   - freq = BQ : 업무 분기 끝 날짜 기준 주기
>
>   - freq = QS : 분기 시작 날짜 기준 주기
>
>   - `pd.date_range(start='2018-10-01',periods=4, freq='QS')`
>
>     - ```
>       DatetimeIndex(['2018-10-01', '2019-01-01', '2019-04-01', '2019-07-01'], dtype='datetime64[ns]', freq='QS-JAN'
>       ```
>
> - 연별 주기로 날짜 생성
>
>   - freq = A : 일년 끝 날짜 기준 주기
>
>   - freq = BA : 업무 일년 끝 날짜 기준 주기
>
>   - freq = AS : 일년 시작 날짜 기준 주기
>
>   - `pd.date_range(start='2018-01-01',periods=4, freq='AS') `
>
>     - ```
>       DatetimeIndex(['2018-01-01', '2019-01-01', '2020-01-01', '2021-01-01'], dtype='datetime64[ns]', freq='AS-JAN')
>       ```
>
> - 시간 기준 주기로 날짜와 시간 생성
>
>   - freq = H : 시간 주기
>
>   - freq = BH : 업무 시간 주기
>
>   - freq = T 또는 min : 분 주기
>
>   - freq = S : 초 주기
>
>   - `pd.date_range(start='2022-01-20 08:00',periods=10, freq='30min')`
>
>     - ```
>       DatetimeIndex(['2022-01-20 08:00:00', '2022-01-20 08:30:00',
>                      '2022-01-20 09:00:00', '2022-01-20 09:30:00',
>                      '2022-01-20 10:00:00', '2022-01-20 10:30:00',
>                      '2022-01-20 11:00:00', '2022-01-20 11:30:00',
>                      '2022-01-20 12:00:00', '2022-01-20 12:30:00'],
>                     dtype='datetime64[ns]', freq='30T')
>       ```

