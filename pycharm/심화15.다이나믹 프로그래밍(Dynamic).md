# 다이나믹 프로그래밍(Dynamic)

> * 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상 시키는 방법
>
> * 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않음
>
> * 일반적으로 두가지 방식인 탑다운과 보텀업으로 구성
>
> * 동적 계획법이라고 불림
>
> * 조건을 만족할때 사용가능
>
>   * 최적 부분 구조(Optimal Substructure)
>     * 큰 문제를 작은 문제로 나눌수 있으며 작은 문제의 답을 모아서 큰 물제를 해결할 수 있음
>   * 중복되는 부분 문제 (Overlapping Subproblem)
>     * 동일한 작은 문제를 반복적으로 해결
>
> * 메모이제이션 (Memoization)
>
>   * 다이나믹 프로그래밍을 구현하는 방법 중 하나
>   * 한번 계산한 결과를 메모리 공간에 메모하는 기법
>   * 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
>   * 값을 기록해 놓는다는 점에서 캐싱(Cashing)이라고 불림
>   * 다이나믹 프로그래밍에만 국한된 개념은 아님
>
> * 탑다운 / 보텀업
>
>   * 탑다운(메모이제이션) 방식은 하향식이라고 하며 보텁업 방식은 상향식
>   * 다이나믹 프로그래밍의 전형적인 형태는 보텀업
>   * 결과 저장용 리스트는 DP 테이블이라고 불림
>
> * 피보나치 수열
>
>   * 재귀로 표현
>
>     * ```
>       def fibo(x):
>           if x==1 or x ==2:
>               return 1
>           return fibo(x-1) + fibo(x-2)
>       ```
>
>       * 지수 시간복잡도
>       * 중복되어 여러번 호출됨
>
>   * 탑 다운
>
>     * ```
>       d = [0] * 100
>       def fibo(x):
>           if x == 1 or x == 2:
>               return 1
>           if d[x] != 0:
>               return d[x]
>           d[x] = fibo(x-1) + fibo(x-2)
>           return d[x]
>       ```
>
>       * 시간 복잡도는 O(N)
>
>   * 보텀업
>
>     * ```
>       d = [0] * 100
>       d[1]=1
>       d[2]=1
>       n=int(input("찾을 값 입력 "))
>       for i in range(3,n+1):
>           d[i] = d[i-1]+d[i-2]
>       
>       print(d[n])
>       ```
>
> * 다이나믹 프로그래밍과 분할 정복에 대해
>
>   * 둘다 최적 부분 구조를 가질때 사용가능
>   * 부분 문제의 중복이 차이점이 있음
>   * 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
>   * 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.
>   * 분할 정복 대표적인 예 `퀵 정렬`
>     * 한번 기준 원소가 자리 변경시 더이상 위치를 바꾸지 않음
>     * 분할 이후 기준 원소를 다시 처리하는 부분 문제는 호출하지 않음
>
> * 그리디,구현,완전 탐색등의 아이디어로 문제 해결할수 있는지 검토후 사용하는게 좋음
>
> * 재귀 함수로 작성해 본뒤 탑다운으로 구현 가능시 사용하는게 좋습니다.