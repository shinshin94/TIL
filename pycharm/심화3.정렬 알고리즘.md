# 정렬 알고리즘

> * `정렬` : 데이터를 특정한 기준에 따라 순서대로 나열
>
> * 일반적으로 문제 상황에 따라 적절한 정렬 알고리즘을 사용
>
## 선택 정렬 
>
>   * ```
>     x=[5,4,2,1,0]
>                 
>     for i in range(len(x)):
>     	minIndex = i
>     	for j in range(i+1,len(x)):
>     		if x[minIndex] > x[j]:
>     			minIndex = j
>     	x[i],x[minIndex] = x[minIndex],x[i]
>     print(x)	#[0,1,2,4,5]
>     ```
>
>   * 시간 복잡도
>
>     * N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.
>
>     * 구현 방식에 따라서 사소한 오차는 있지만 전체 연산 횟수는`N+(N-1)+(N-2)+...+2`
>
>     * `(N**2+N-2)/2`로 표현 가능 ,빅오 표기법에 따라 `O(N**2)`로 작성
>     
## 삽입 정렬
>
>     * 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
>
>     * 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작
>
>     * 시간 복잡도
>
>     * 삽입 정렬의 시간 복잡도는 `O(N**2)`이며,선택 정렬과 마찬가지로 반복문이 두번 중첩되어 사용
>
>     * 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작
>       * 최선의 경우  `O(N**2)`의 시간 복잡도
>       
>     * ```
>       x = [5,4,2,1,0]
>       
>       for i in range(1,len(x)):
>       	for j in range(i,0,-1):
>       		if x[j] < x[j-1]:
>       			x[j],x[j-1] = x[j-1],x[j]
>       		else:
>       			break
>       print(x)
>       ```
>

## 퀵 정렬

> * 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
>
> * 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘
>
> * 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간
>
> * 가장 기본적인 퀵 정렬은 첫번째 데이터를 기준 데이터(Pivot)로 설정
>
> * 동작 순서
>
>   1. 기준데이터의 왼쪽에서부터 기준데이터보다 큰 데이터를 선택
>   2. 오른쪽에서부터는 기준 데이터보다 작은 데이터를 선택
>   3. 1과2를 서로 바꿔줍니다.
>   4. 다시 1,2,3을 반복합니다.
>   5. 반복시 선택한것의 위치가 엇갈릴 경우 기준 데이터와 작은 데이터의 위치를 교체합니다.
>   6. 왼쪽에는 기준보다 작은수, 오른쪽에는 기준보다 큰 수로 데이터들을 둡니다. (분할)
>
> * 퀵 정렬이 빠른 이유(직관적 이해)
>
>   * 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수 `O(NlogN)` (너비X높이 = N x logN = NlogN)
>
> * 퀵 정렬의 시간 복잡도
>
>   * 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도
>   * 최악의 경우 O(N**2)의 시간 복잡도
>
> * 일반적인 방식
>
>   * ```
>     x=[4,7,2,5,7,8,3,1,8]
>     
>     def quick(x,start,end):
>     	if start >= end:
>     		return
>     	pivot = start
>     	left = start + 1
>     	right = end
>     	while(left <= right):
>     		while(left <= end and x[left] <= x[pivot]):
>     			left +=1
>     		while(right > start and x[right] >= x[pivot]):
>     			right -=1
>     		if(left > right):
>     			x[right],x[pivot] = x[pivot],x[right]
>     		else:
>     			x[left],x[right] = x[right],x[left]
>     	quick(x,start,right -1)
>     	quick(x,right +1,end)
>     	
>     quick(x,0,len(x)-1)
>     print(x)		#[1, 2, 3, 4, 5, 7, 7, 8, 8]
>     ```
>
> * 파이썬의 빠른 방식
>
>   * ```
>     x=[4,7,2,5,7,8,3,1,8]
>     
>     def quick(x):
>     	if len(x) <= 1:
>     		return x
>     	pivot = x[0]
>     	tail = x[1:]
>     	
>     	left = [x for x in tail if x <= pivot]
>     	right = [x for x in tail if x > pivot]
>     	
>     	return quick(left)+[pivot]+quick(right)
>     
>     print(quick(x))			#[1, 2, 3, 4, 5, 7, 7, 8, 8]
>     ```

## 계수 정렬

> 1. 모두 담길수 있는 범위의 리스트 생성
> 2. 데이터를 확인후 데이터 값과 동일한 인덱스의 데이터를 1씩 증가
> 3. 최종적으로 리스트에 각 데이터가 몇번씩 등장했는지 횟수가 기록 됨
> 4. 결과를 확인할 때는 리스트의 첫번쨰 데이터부터 하나씩 그 값만큼 반복하여 인덱스 출력
>
> * ```
>   x=[7,4,3,2,1,1,6,7,8,5]
>   count=[0]*(max(x)+1)
>   
>   for i in range(len(x)):
>   	count[x[i]]+=1
>   for i in range(len(count)):
>   	for j in range(count[i]):
>   		print(i,end=" ")			#1 1 2 3 4 5 6 7 7 8 
>   ```
>
> * 복잡도 분석
>
>   * 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N+K)
>   * 계수 정렬은 때에 따라 심각한 비효율
>     * 데이터가 0과 98393 같이 단 2개만 존재할경우 손해
>   * 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할때 효과적

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| ------------- | ---------------- | ----------- | ------------------------------------------------------------ |
| 선택 정렬     | O(N**2)          | O(N)        | 아이디어가 매우 간단합니다.                                  |
| 삽입 정렬     | O(N**2)          | O(N)        | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.              |
| 퀵 정렬       | O(NlogN)         | O(N)        | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다.              |
| 계수 정렬     | O(N+K)           | O(N + K)    | 데이터의 크기가 한정되어 있는경우만 사용가능하지만 매우 빠릅니다. |

